const path = require('path')
const { worker } = require('workerpool')
const pSeries = require('p-series')
const { Print, chalk } = require('@ianwalter/print')
const { threadId } = require('worker_threads')

worker({
  async register (context, { file }) {
    const print = new Print({ level: context.logLevel })
    const filePath = path.relative(process.cwd(), file)
    print.debug(`Registration worker ${threadId}`, chalk.gray(filePath))
    const { toHookExec } = require('./src/lib')

    // Create the registration context with the list of tests that are intended
    // to be executed.
    const needsTag = context.tags && context.tags.length
    const toTests = (acc, [name, { skip, only, tags }]) => {
      const test = { key: name, name, skip, only, tags }
      if (!needsTag || (needsTag && tags.some(t => context.tags.includes(t)))) {
        acc.push(test)
      }
      return acc
    }
    const tests = Object.entries(require(file)).reduce(toTests, [])
    context.registrationContext = { file, tests }

    // Execute each function with the test names exported by the files
    // configured to be called during test registration.
    if (context.plugins && context.plugins.length) {
      await pSeries(
        context.plugins.map(toHookExec('registration', context))
      )
    }

    return context.registrationContext.tests
  },
  async test (context, fileContext, test) {
    const expect = require('expect')
    const {
      addSerializer,
      toMatchSnapshot,
      toMatchInlineSnapshot,
      toThrowErrorMatchingSnapshot,
      toThrowErrorMatchingInlineSnapshot
    } = require('jest-snapshot')
    const { toHookRun, createTestContext, runTest } = require('./src/lib')

    const print = new Print({ level: context.logLevel })
    print.debug(
      `Test worker ${threadId}`,
      chalk.cyan(test.name),
      chalk.gray(path.relative(process.cwd(), fileContext.file))
    )

    // Extend the expect with jest-snapshot to allow snapshot testing.
    expect.extend({
      toMatchInlineSnapshot,
      toMatchSnapshot,
      toThrowErrorMatchingInlineSnapshot,
      toThrowErrorMatchingSnapshot
    })
    expect.addSnapshotSerializer = addSerializer

    // Create the context object that provides data and utilities to tests.
    const testContext = createTestContext(context, fileContext, test, expect)

    // Run beforeEach hooks from plugins.
    if (context.plugins && context.plugins.length) {
      try {
        await pSeries(context.plugins.map(toHookRun('beforeEach', context)))
      } catch (err) {
        print.error(err)
      }
    }

    // Load the test file and extract the test function.
    const { testFn } = require(fileContext.file)[test.key]

    // TODO:
    await runTest(testContext, testFn, context.timeout)

    // Run afterEach hooks from plugins.
    if (context.plugins && context.plugins.length) {
      try {
        await pSeries(
          context.plugins.map(toHookRun('afterEach', context))
        )
      } catch (err) {
        print.error(err)
      }
    }

    // TODO:
    return testContext.result
  },
  async pptr (context, fileContext) {
    const puppeteer = require('puppeteer')
    const webpack = require('webpack')
    const merge = require('@ianwalter/merge')
    const MemoryFileSystem = require('memory-fs')

    const print = new Print({ level: context.logLevel })
    print.debug(
      `Test worker ${threadId}`,
      '(Puppeteer)',
      chalk.gray(path.relative(process.cwd(), fileContext.file))
    )

    // Launch the Puppeteer browser and create the page instance.
    const browser = await puppeteer.launch(context.puppeteer)
    const page = await browser.newPage()

    // Create an in-memory filesystem to use with Webpack.
    const mfs = new MemoryFileSystem()

    // Create the Webpack compiler.
    const options = {
      mode: 'development',
      target: 'web',
      entry: 'main.js',
      outputFileSystem: mfs
    }
    const compiler = webpack(merge(options, context.puppeteer.webpack))

    return new Promise((resolve, reject) => {
      // Create the bundle by running the Webpack compiler.
      compiler.run(async err => {
        if (err) {
          reject(err)
        }

        try {
          // Read the code generated by the Webpack compiler from the memory
          // filesystem.
          const bundle = mfs.readFileSync(fileContext.file, 'utf8')

          // TODO:
          page.addScriptTag({ mode: true, source: bundle })

          // TODO:
          const browserPath = path.join(__dirname, 'dist', 'browserMain.js')
          page.addScriptTag({ module: true, path: browserPath })

          // TODO:
          context.workerPath = path.join(__dirname, 'dist', 'browserWorker.js')

          // TODO:
          resolve(await page.evaluate(
            ({ context, fileContext }) => window.runTests(context, fileContext),
            { context, fileContext }
          ))
        } catch (err) {
          reject(err)
        }
      })
    })
  }
})
